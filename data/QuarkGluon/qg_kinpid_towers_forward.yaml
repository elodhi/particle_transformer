selection:
   ### use `&`, `|`, `~` for logical operations on numpy arrays
   ### can use functions from `math`, `np` (numpy), and `awkward` in the expression
   'jets_eta > 2.5' # h5 reader function currently defined so that it will automatically take abs(jets_eta)

new_variables:
   ### [format] name: formula
   ### can use functions from `math`, `np` (numpy), and `awkward` in the expression
   mask: ak.ones_like(flow_deta)
   flow_log_pt: np.log(flow_pt)
   flow_lognorm_pt: np.log(flow_pt/jets_pt[:, np.newaxis])
   flow_log_E: np.log(flow_energy)
   flow_lognorm_E: np.log(flow_energy/jets_energy[:, np.newaxis])
   flow_radius: np.sqrt(flow_deta ** 2 + flow_dphi ** 2)
   towers_log_pt: np.log(towers_pt)
   towers_lognorm_pt: np.log(towers_pt/jets_pt[:, np.newaxis])
   towers_log_E: np.log(towers_energy)
   towers_lognorm_E: np.log(towers_energy/jets_energy[:, np.newaxis])
   towers_radius: np.sqrt(towers_deta ** 2 + towers_dphi ** 2)
   jet_isQ: jets_PartonTruthLabelID
   jet_isG: 1-jets_PartonTruthLabelID
   flow_px: flow_pt*np.cos(flow_dphi)
   flow_py: flow_pt*np.sin(flow_dphi)
   flow_pz: flow_pt*np.sinh(flow_deta)
   towers_px: towers_pt*np.cos(towers_dphi)
   towers_py: towers_pt*np.sin(towers_dphi)
   towers_pz: towers_pt*np.sinh(towers_deta)

preprocess:
  ### method: [manual, auto] - whether to use manually specified parameters for variable standardization
  method: manual
  ### data_fraction: fraction of events to use when calculating the mean/scale for the standardization
  data_fraction: 0.5

inputs:
   pf_points: #not used by ParT
      length: 120
      pad_mode: wrap
      vars: 
         - [flow_deta, null]
         #- [jets_pt, null]
   pf_features:
      length: 120
      pad_mode: wrap
      vars: 
      ### [format 1]: var_name (no transformation)
      ### [format 2]: [var_name, 
      ###              subtract_by(optional, default=None, no transf. if preprocess.method=manual, auto transf. if preprocess.method=auto), 
      ###              multiply_by(optional, default=1), 
      ###              clip_min(optional, default=-5), 
      ###              clip_max(optional, default=5), 
      ###              pad_value(optional, default=0)]
         - flow_deta
         - flow_dphi
         - flow_log_pt
         - flow_log_E
         - flow_lognorm_pt
         - flow_lognorm_E
         - flow_radius
         #- towers_log_pt
         #- towers_log_E
         #- towers_lognorm_pt
         #- towers_lognorm_E
         #- towers_radius
   pf_vectors:
      length: 120
      pad_mode: wrap
      vars: 
         - [flow_px, null]
         - [flow_py, null]
         - [flow_pz, null]
         - [flow_energy, null]
         #- [towers_px, null]
         #- [towers_py, null]
         #- [towers_pz, null]
         #- [towers_energy, null]
   pf_mask:
      length: 120
      pad_mode: constant
      vars: 
         - [mask, null]

labels:
   ### type can be `simple`, `custom`
   ### [option 1] use `simple` for binary/multi-class classification, then `value` is a list of 0-1 labels
   type: simple
   value: [jet_isQ, jet_isG]
   ### [option 2] otherwise use `custom` to define the label, then `value` is a map
   # type: custom
   # value: 
   #    truth_label: label.argmax(1)

observers:
   - jets_pt
   - jets_eta
   #- wgts

weights:
    use_precomputed_weights: False
    reweight_method: flat
    reweight_basewgt: False
    reweight_vars:
        jets_pt: [20000.,  56000.,  92000., 128000., 164000., 200000.]
        jets_eta: [2.5 , 2.82, 3.14, 3.46, 3.78, 4.1 ] 
    reweight_classes: [
        jet_isQ, jet_isG
        ]
    class_weights: [
        1, 1
        ]

        